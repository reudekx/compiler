C++과 Rust를 주로 참고하고 있으므로 해당 언어들의 특성을 여기에 정리한다.
어느 정도 검증은 하겠지만 AI의 도움을 많이 받았기 떄문에 필요시 추가적인 검색을 통해 엄밀히 따져봐야 할 수 있음.



C++의 생성자, 소멸자

    1. 생성자
        MyClass a;
        MyClass a(10);
        
    2. 복사 생성자
        MyClass a;
        MyClass b(a);

    3. 소멸자
        스택 객체의 경우 스코프 종료시 호출,
        힙 객체는 delete시 호출


    위 3가지 함수는 반환 타입이 없다.
    

    4. 복사 대입 생성자
        MyClass a = b;

        반환 타입이 MyClass&이다.
        연쇄 할당이 가능하기 위해서는 좌측 변수가 레퍼런스를 반환해야 하기 때문

        MyClass a = b = c;
            이때 b가 복사 대입 생성자를 호출하고 스스로에 대한 레퍼런스를 반환한다.
            그럼 이걸 a가 복사 대입 생성자 호출시 인자로 이용한다.

    5. 이동 생성자
        

    6. 이동 대입 생성자

C++의 lvalue, prvalue, xvalue, glvalue, rvalue

    검색을 하다보니 위 용어가 자주 등장하던데..
        실제로 각각에 대한 엄밀한 정의를 알고 구분짓는 게 중요한지,
        아니면 코드 작성 과정에서 자연히 도출되는 부가적인 정보일 뿐인지 정리를 하면서 알아보자

    참고 링크
        https://learn.microsoft.com/ko-kr/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170

    (찾아보면서 느낀 건데.. C++의 여러 특성을 위 용어들을 기반으로 설명하는 글이 많이 보이기 때문에
        정확한 정의를 아는 것이 필요할 듯 하다.)

        또한 결국 컴파일러 구현 시 명확한 구분을 해야 컴파일 오류를 발생시킬 수 있음.

    
    identity, move의 여부에 따라 구분이 된다.

    1. lvalue
        identity를 가지고, move될 수 없다.

    2. xvalue
        identity를 가지고, move될 수 있다.

    3. prvalue
        identity를 가지지 않고, move될 수 있다.

    모든 value는 이상의 3가지 중 하나에 속하게 된다.

    더 큰 분류를 살펴 보면,

    1. rvalue
        move될 수 있다.

    2. glvalue
        identity를 가진다.

    xvalue를 정확히 알기 위해서,
    rvalue reference와 std::move에 대해 이해할 필요가 있다.

        std::move의 역할은?

        가령, std::move(Object());
        이 코드는 argument 객체를 Object&& (ravlue reference)로 캐스팅한다.

        이제 다음의 대입문을 확인해보자.
        Object object = std::move(Object());

        std::move를 통해, 복사 대입 연산자와 이동 대입 연산자 중, 후자가 선택되게 된다.

        결국 std::move의 역할은 = 연산자의 구현 중 rvalue reference 타입의 파라미터를 가지는
        오버로드가 선택될 수 있도록 하는 것이다.

        또한 move될 수 없는 lvalue를 xvalue로 캐스팅 해주는 역할이라고 봐도 될.. 것 같다.

    나름대로 결론을 내려보자면..
        복사와 이동을 구분하여 개발을 할 수 있도록,
        rvalue reference 타입을 도입했고,
        C++의 함수 오버로딩 기능을 이용하여 = 연산자만으로 이동과 복사를 모두 처리할 수 있게 되었다.
        물론 형변환이 이뤄져야 하니까.. std::move가 그 역할을 해준다.

        Object object = static_cast<Object&&>(Object());

        Object object = std::move(Object());

        위 둘은 동일한 기능을 수행하는 듯하다. (검증 필요)

C++의 copy elision

    복사 생략이 언제 이뤄지는지 알아보자.

    1. 
    

C++의 가상 함수, 가상 상속

    1. 가상 함수
        virtual 함수를 통해 객체가 vtable에 대한 포인터를 지니도록 하고,
        이를 통해 다형성을 구현할 수 있다.
    
    2. 가상 상속
        virtual 상속을 하게 되면, virtual 상속의 대상이 되는 부모의 필드를 가리키는
        포인터를 추가로 유지하게 된다.

        그래서 다이아몬드 상속이 이뤄졌을 때, Top -> Left, Right -> Bottom의 구조일 때,
        Bottom의 메모리 레이아웃에서 Left와 Right는 Top에 대한 필드를 가지지 않고
        Bottom이 지닌 Top의 필드의 위치를 참조하는 포인터를 지닌다.

        그러면.. 예를 들어 Left left = Bottom(); 과 같은 코드에서,
        Bottom에 있는 Top 필드는 Left로의 형변환 시 누락되지만,
        left에는 잘려나간 Top 필드를 가리키는 포인터가 있기 때문에 여전히 Top의 필드에 접근할 수 있게 된다.

    (뇌피셜로 쓴 게 많아서 추후 검증 필요)


Rust의 trait

    1. 정적 디스패치
        제네릭과 impl trait(단일 trait 바운드 제네릭으로 간주할 수 있다)

    2. 동적 디스패치
        dyn trait