언어 컨셉

구조체 & 트레이트 (문법이 아닌 개념만 정리)
    구조체 -> 데이터 구조를 정의한다.
    트레이트 -> 인터페이스를 정의한다.
    구조체 변수 -> 값만을 저장
    트레이트 변수 -> 객체의 주소와 타입에 대한 dispatch table 주소를 함께 보관 (값 할당 시 결정됨)

복사 생략
    C++의 prvalue에 대한 copy elision과 같은 기능을 구현해야 한다.

    일관적으로 복사 생략이 이뤄지도록 규칙을 세워야 함.

    assembly 단계에서는 어떻게 나타날지 생각해보자..

    copy elision을 위해서는 함수에 반환값이 저장될 외부 변수의 주소를 전달할 필요가 있다.

    물론 copy elision이 일어나든 안 일어나든 상관없이 함수 type만으로 이를 결정해야 함. (함수가 1급 객체이기 떄문에)

    그렇다면 언제 주소를 전달하고, 언제 전달하지 않을지에 대한 규칙을 세워야 한다.

    가령 반환값 크기가 작은 경우 그냥 레지스터에 반환하도록 하는 게 나을 수 있다.
        -> 대신 prvalue인 경우 함수 내부에 복사 생성자를 호출하는 로직을 삽입하지 않아야 한다.

    반환값이 큰 경우에는, 함수에 숨겨진 인자로서 반환값이 담길 주소를 전달한다.
        -> 이때 prvalue인 경우에는, 반환이 되는 지역 변수를 선언 하지 않고 인자로 받은 주소를 그대로 이용한다.
        -> prvalue가 아닌 경우에는, 최후에 해당 주소로 복사를 수행하고 복사 생성자도 호출한다. (물론 복사 생성자를 지원할지는 아직 미결정)

어셈블리 단계에서 함수 호출 규약
    각 아키텍쳐에 맞는 ABI 호출 규약을 따르면 된다.

    이를 기반으로 위의 복사 생략에 대한 규칙을 세우면 됨.


구조체 & 배열 생성 문법

    struct Data {
        value i32
    }

    var data Data = Data { 32 }

    var data := Data { 32 }

    # 배열
    var array [i32; 5] = [1, 2, 3, 4, 5]

포인터 및 힙 할당 & 배열 포인터, 함수 포인터
    포인터가 존재함.

    struct Data {
        value i32
    }

    var ptr *Data = new Data { 3 }

    

전역 변수 & 지역 변수 & const
    Rust처럼 전역 변수와 같이 static lifetime을 가지는 객체들을 전부 static으로 통일

    const는 컴파일러가 직접 값으로 치환해줌

클로저
    클로저를 어떻게 지원할까?

    암묵적인 힙 승격 대신 바인딩 문법을 이용?

    가령 struct가 trait의 함수를 구현한 경우

    data.method() 와 같이 해당 함수를 호출하면 object가 method의 self 인수로서 삽입된다.

    즉 method는 실제로 self라는 포인터를 첫번째 인자로 가지고 있고

    dot 연산자에 의해 앞선 data 전달된 것이다.

    만약 이처럼 바인딩된 함수를 1급 객체로서 다룰 수 있다면?

    예를 들어 funtion = data.method 같은 경우..

    function은 data 대한 참조를 보관해야 하고 function()과 같이 호출 시 
    해당 참조를 method의 첫번째 인자에 전달해야 한다.
    즉 function은 실제로는
    {
        data *Data
        function fun(*Data) -> i32 
    }
    위와 같은 형태로 구성될 것이다.

    내 생각에는 함수/클로져를 구분하지 않으면 추상화에 대한 오버헤드가 생기므로..

    Rust처럼 fn(함수 포인터)와 Fn(클로저, 함수를 담는 타입)을 구분하듯 이 컴파일러가 아닌 언어 차원에서 구분하도록 하는 게 나을 것 같다..

    결론:
        클로저 타입을 따로 구분하자.

생성자 & 소멸자
    포인터를 명시적으로 할당/해제 하므로
    C++의 RAII 패턴과 같은 것이 가능하도록 지원할 필요가 있다.
        -> 생성자와 소멸자를 사용자 정의 가능하도록 해야 한다.


스택 할당 & 힙 할당 (어셈블리어에서)

    스택 할당의 경우.. 일단 지역변수의 경우 변수 수명 등을 계산한 뒤 적절히
    rbp를 기준으로 상대적인 index로 치환해야 한다.

    반환값이 있지만 사용되지 않는 함수나, 연쇄적으로 호출되는 함수들의 경우는? a().b().c() or a()()()
        결과값을 rsp를 기준으로 저장하면 될 것 같다. 어차피 다시 참조될 일은 없으니까 
        -> 실제 컴파일러가 어떻게 하는지는 잘 모르겠지만 비슷하지 않을까 싶음

    힙 할당의 경우..
        일단 이번 버전에서는 malloc을 extern으로 선언하여 사용하자.. free도 마찬가지
        (나중에 직접 구현해보자.)

동적 디스패치 & 정적 디스패치
    trait를 통해 동적 디스패치를 수행할 수 있다.
    
    다만, trait 객체에서 Self와 같은 키워드가 정의에 포함되어 trait를 구현할 때 type이 결정되는 경우
        Self가 포인터거나 스마트 포인터에 의해 wrapping된 것이 아닌 이상 함수의 spec이 구현체마다 달라지기 때문에
        이 경우 dyn 객체를 생성할 수 없다.

        -> 문법을 통해 명시할 필요가 있을까? 물론 컴파일러가 Self의 존재 여부를 파악해서 구분해도 되긴 함..
            (고민 중)

    정적 디스패치
        generics의 경우 정적 디스패치가 수행된다.
        
        impl Trait의 경우에도 정적 디스패치가 수행된다.