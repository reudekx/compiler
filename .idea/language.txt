언어 컨셉

구조체 & 트레이트
    구조체 -> 데이터 구조를 정의한다.
    트레이트 -> 인터페이스를 정의한다.
    구조체 변수 -> 값만을 저장
    트레이트 변수 -> 객체의 주소와 타입에 대한 dispatch table 주소를 함께 보관 (값 할당 시 결정됨)

복사 생략
    C++의 prvalue에 대한 copy elision과 같은 기능을 구현해야 한다.

    일관적으로 복사 생략이 이뤄지도록 규칙을 세워야 함.

    assembly 단계에서는 어떻게 나타날지 생각해보자..

    copy elision을 위해서는 함수에 반환값이 저장될 외부 변수의 주소를 전달할 필요가 있다.

    물론 copy elision이 일어나든 안 일어나든 상관없이 함수 type만으로 이를 결정해야 함. (함수가 1급 객체이기 떄문에)

    그렇다면 언제 주소를 전달하고, 언제 전달하지 않을지에 대한 규칙을 세워야 한다.

    가령 반환값 크기가 작은 경우 그냥 레지스터에 반환하도록 하는 게 나을 수 있다.
        -> 대신 prvalue인 경우 함수 내부에 복사 생성자를 호출하는 로직을 삽입하지 않아야 한다.

    반환값이 큰 경우에는, 함수에 숨겨진 인자로서 반환값이 담길 주소를 전달한다.
        -> 이때 prvalue인 경우에는, 반환이 되는 지역 변수를 선언 하지 않고 인자로 받은 주소를 그대로 이용한다.
        -> prvalue가 아닌 경우에는, 최후에 해당 주소로 복사를 수행하고 복사 생성자도 호출한다. (물론 복사 생성자를 지원할지는 아직 미결정)

어셈블리 단계에서 함수 호출 규약
    결국 이에 대한 규칙을 세우는 것이 선행되어야 복사 생략을 지원할 수 있다.

    함수 인자의 타입, 반환 타입을 중점으로 규칙을 세우면 된다.

    크기 기준으로는.. (고민 중)


포인터 및 힙 할당
    포인터가 존재함.

    struct Data {
        value i32
    }

    Data* data2 = new Data {
        32
    }

    Data* data2 = new { 10 }

    new 연산자를 어떻게 설정할지도 고민 중.
    뒤에 나온 표현식의 결과값을 초기값으로 하는 객체를 힙에 할당하고 그 주소를 반환하는 것으로 할지..
    (또한 뒤에 type이 나오는 경우 값 초기값 없이 힙 할당)

    