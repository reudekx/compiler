언어 컨셉

구조체 & 트레이트 (문법이 아닌 개념만 정리)
    구조체 -> 데이터 구조를 정의한다.
    트레이트 -> 인터페이스를 정의한다.
    구조체 변수 -> 값만을 저장
    트레이트 변수 -> 객체의 주소와 타입에 대한 dispatch table 주소를 함께 보관 (값 할당 시 결정됨)

복사 생략
    C++의 prvalue에 대한 copy elision과 같은 기능을 구현해야 한다.

    일관적으로 복사 생략이 이뤄지도록 규칙을 세워야 함.

    assembly 단계에서는 어떻게 나타날지 생각해보자..

    copy elision을 위해서는 함수에 반환값이 저장될 외부 변수의 주소를 전달할 필요가 있다.

    물론 copy elision이 일어나든 안 일어나든 상관없이 함수 type만으로 이를 결정해야 함. (함수가 1급 객체이기 떄문에)

    그렇다면 언제 주소를 전달하고, 언제 전달하지 않을지에 대한 규칙을 세워야 한다.

    가령 반환값 크기가 작은 경우 그냥 레지스터에 반환하도록 하는 게 나을 수 있다.
        -> 대신 prvalue인 경우 함수 내부에 복사 생성자를 호출하는 로직을 삽입하지 않아야 한다.

    반환값이 큰 경우에는, 함수에 숨겨진 인자로서 반환값이 담길 주소를 전달한다.
        -> 이때 prvalue인 경우에는, 반환이 되는 지역 변수를 선언 하지 않고 인자로 받은 주소를 그대로 이용한다.
        -> prvalue가 아닌 경우에는, 최후에 해당 주소로 복사를 수행하고 복사 생성자도 호출한다. (물론 복사 생성자를 지원할지는 아직 미결정)

어셈블리 단계에서 함수 호출 규약
    각 아키텍쳐에 맞는 ABI 호출 규약을 따르면 된다.

    이를 기반으로 위의 복사 생략에 대한 규칙을 세우면 됨.


구조체 & 배열 생성 문법

    struct Data {
        value i32
    }

    var data Data = Data { 32 }

    var data := Data { 32 }

    # 배열
    var array [i32; 5] = [1, 2, 3, 4, 5]

포인터 및 힙 할당 & 배열 포인터, 함수 포인터
    포인터가 존재함.

    struct Data {
        value i32
    }

    var ptr *Data = new Data { 3 }

    

전역 변수 & 지역 변수 & const
    Rust처럼 전역 변수와 같이 static lifetime을 가지는 객체들을 전부 static으로 통일

    const는 컴파일러가 직접 값으로 치환해줌

클로저
    클로저를 어떻게 지원할까?

    암묵적인 힙 승격 대신 바인딩 문법을 이용?

    가령 struct가 trait의 함수를 구현한 경우

    data.method() 와 같이 해당 함수를 호출하면 object가 method의 self 인수로서 삽입된다.

    즉 method는 실제로 self라는 포인터를 첫번째 인자로 가지고 있고

    dot 연산자에 의해 앞선 data 전달된 것이다.

    만약 이처럼 바인딩된 함수를 1급 객체로서 다룰 수 있다면?

    예를 들어 funtion = data.method 같은 경우..

    function은 data 대한 참조를 보관해야 하고 function()과 같이 호출 시 
    해당 참조를 method의 첫번째 인자에 전달해야 한다.
    즉 function은 실제로는
    {
        data *Data
        function fun(*Data) -> i32 
    }
    위와 같은 형태로 구성될 것이다.

    object에 대한 참조를 